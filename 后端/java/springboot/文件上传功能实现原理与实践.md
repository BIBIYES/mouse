# 文件上传功能实现原理与实践

## 1 文件上传的核心概念

想象一下，如果你要把一张照片从手机发给朋友，你会怎么做？你可能会通过微信或邮件把这个文件传过去。在 Web 应用中，文件上传也是类似的过程：用户选择文件，然后通过浏览器把文件传到服务器，就像寄快递一样。

### 1.1 文件上传流程简述

文件上传就像寄快递的过程：

1. **打包**：用户在网页上选择文件（打包物品）

2. **寄送**：浏览器将文件发送到服务器（通过快递员送到目的地）

3. **签收**：服务器接收文件（目的地收到包裹）

4. **保存**：服务器将文件保存到特定位置（包裹放入仓库）

5. **记录**：在数据库记录文件信息（记录包裹的位置和信息）

## 2 项目中的文件上传实现

### 2.1 配置文件（application.yaml）

配置文件就像是一份说明书，告诉应用程序在哪里存放文件以及如何访问这些文件：

```yaml

# 文件上传配置

file:

  upload:

    # 文件上传基本路径

    base-path: C:/files/

    # 文件访问URL前缀

    access-url: /files/

```

这就像是告诉快递员："所有的包裹都应该送到 C:/files/这个仓库，而且通过/files/这个门可以进入查看"。

### 2.2 控制器层（FileResourceController）

控制器就像是接待员，负责接收用户的文件并交给后续的处理流程：

```java

@Slf4j

@RestController

@RequestMapping("/v1/file-resource")

public class FileResourceController {

  

    @Autowired

    private IFileResourceService fileResourceService;

  

    /**

     * 上传文件接口

     */

    @PostMapping("/upload")

    public Result<String> uploadFile(@RequestParam("file") MultipartFile file, HttpServletRequest request) {

        log.info("收到文件上传请求，文件名: {}, 大小: {}", file.getOriginalFilename(), file.getSize());

        return fileResourceService.uploadFile(file, request);

    }

}

```

这就像前台接待员：接收到快递后，记录一下"收到了什么快递、多大的包裹"，然后转交给仓库管理员（服务层）处理。

### 2.3 服务层（FileResourceServiceImpl）

服务层负责核心业务逻辑，就像仓库管理员，决定如何处理收到的文件：

```java

@Override

public Result<String> uploadFile(MultipartFile file, HttpServletRequest request) {

    try {

        // 检查文件是否为空

        if (file.isEmpty()) {

            return Result.error("上传文件不能为空");

        }

  

        // 读取文件为字节数组并计算哈希值

        String hashData = DigestUtils.sha256Hex(file.getInputStream().readAllBytes());

  

        // 查询是否存在相同文件

        FileResource exist = getOne(new LambdaQueryWrapper<FileResource>()

            .eq(FileResource::getHashData, hashData));

  

        // 如果文件已存在，直接返回路径

        if (exist != null) {

            return Result.success("文件已存在", fileAccessUrl + exist.getPath());

        }

  

        // 构建文件存储路径

        String fileName = hashData + getFileExtension(file.getOriginalFilename());

        String relativePath = getYearMonthPath();

  

        // 保存文件

        saveFile(file, baseUploadPath + relativePath + fileName);

  

        // 保存文件记录到数据库

        FileResource fileResource = createFileResource(file, hashData, relativePath + fileName);

        this.save(fileResource);

  

        return Result.success("上传成功", fileAccessUrl + fileResource.getPath());

    } catch (Exception e) {

        log.error("文件上传失败", e);

        return Result.error("上传失败，请稍后再试");

    }

}

```

仓库管理员的工作流程：

1. 先看看包裹是否为空（不能收空包裹）

2. 计算包裹的"指纹"（哈希值）

3. 查询仓库记录，看看是否收过相同的包裹

4. 如果已经有了相同的包裹，就告诉用户已有的包裹位置

5. 否则，为包裹创建存储位置（按年月分类存放）

6. 把包裹存放到仓库中

7. 在记录本（数据库）中记录这个包裹的信息

8. 告诉用户包裹已成功保存，并给出查看位置

### 2.4 实体层（FileResource）

实体类就像是一个记录表格，描述每个文件的特征：

```java

@Data

@TableName("file_resource")

public class FileResource {

    @TableId(value = "id", type = IdType.AUTO)

    private Long id;

    private String hashData;   // 文件指纹

    private String path;       // 存储路径

    private String originalName; // 原始文件名

    private String fileType;   // 文件类型

    private Long fileSize;     // 文件大小

    private LocalDateTime uploadTime; // 上传时间

}

```

这就像快递仓库的登记表：每个包裹都有唯一编号、包裹特征码、存放位置、原始名称、类型、大小和收到时间。

### 2.5 安全配置（WebConfig）

安全配置就像门卫，决定谁能进入仓库，谁不能：

```java

@Override

public void addInterceptors(InterceptorRegistry registry) {

    registry.addInterceptor(jwtInterceptor)

            .addPathPatterns("/v1/**")

            .excludePathPatterns(

                    // 排除不需要验证的路径

                    "/v1/users/login",

                    "/v1/users/register",

                    // ...其他路径

                    // 静态资源文件访问路径

                    fileAccessUrl + "**"

            );

}

```

这就像设置了两种不同的门：

- 对于想要送包裹（上传文件）的人，需要持有有效证件（JWT 令牌）才能进入

- 对于想要查看包裹（访问文件）的人，可以直接通过开放通道进入

### 2.6 数据库表结构

数据库表就像是一本详细的记录簿：

```sql

CREATE TABLE `file_resource` (

  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',

  `hash_data` varchar(64) NOT NULL COMMENT '文件SHA256哈希值，用于文件去重',

  `path` varchar(255) NOT NULL COMMENT '文件存储相对路径',

  `original_name` varchar(255) DEFAULT NULL COMMENT '原始文件名',

  `file_type` varchar(100) DEFAULT NULL COMMENT '文件MIME类型',

  `file_size` bigint(20) DEFAULT NULL COMMENT '文件大小（字节）',

  `upload_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '上传时间',

  PRIMARY KEY (`id`),

  UNIQUE KEY `uk_hash_data` (`hash_data`) COMMENT '哈希值唯一索引，用于去重',

  KEY `idx_upload_time` (`upload_time`) COMMENT '上传时间索引'

) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文件资源存储表';

```

这就像一本有着固定格式的登记簿，每行记录一个包裹，包含 ID、特征码、位置、原名、类型、大小和时间等信息。

## 3 设计亮点与优势

### 3.1 文件去重机制

想象一下，如果小明和小红分别上传了同一张照片，我们没必要存储两份完全相同的文件。我们的系统会计算文件的"指纹"（SHA256 哈希值），如果发现已经有相同"指纹"的文件，就直接返回已有文件的路径，节省存储空间。

这就像仓库管理员检查到两个包裹内容完全一样，就不会重复存储，而是告诉后来的人："你的东西和之前那个是一样的，在这个位置"。

### 3.2 按年月目录存储

我们将文件按照上传的年月分类存储：

```java

String yearMonth = now.getYear() + "-" + String.format("%02d", now.getMonthValue());

String relativePath = yearMonth + "/";

```

这就像仓库按照收货日期分区存放，方便日后查找和管理。想找 2023 年 6 月的文件？直接去"2023-06"文件夹看就行了。

### 3.3 安全控制

我们采用了 JWT 拦截器来保护上传接口，只有登录用户才能上传文件：

```java

registry.addInterceptor(jwtInterceptor)

        .addPathPatterns("/v1/**")

        .excludePathPatterns(

                // ...排除路径

                // 静态资源文件访问路径

                fileAccessUrl + "**"

        );

```

这就像仓库的进出管理：送包裹需要出示工作证，但查看包裹可以自由进入，避免了恶意用户上传有害文件。

### 3.4 配置驱动

通过配置文件设置存储路径和访问 URL，而不是硬编码：

```yaml

file:

  upload:

    base-path: C:/files/

    access-url: /files/

```

这就像是可以方便地更换仓库地址而不需要重建整个系统。如果将来需要把文件存储到 D 盘或云存储，只需修改配置文件，不用改动代码。

## 4 实用技巧

### 4.1 使用方法

前端上传文件的简单示例：

```html

<form

  method="post"

  action="/api/v1/file-resource/upload"

  enctype="multipart/form-data"

>

  <input type="file" name="file" />

  <button type="submit">上传</button>

</form>

```

也可以使用 AJAX 实现更现代的上传体验：

```javascript

const uploadFile = async (file) => {

  const formData = new FormData();

  formData.append("file", file);

  

  const response = await fetch("/api/v1/file-resource/upload", {

    method: "POST",

    headers: {

      Authorization: "Bearer " + token, // JWT令牌

    },

    body: formData,

  });

  

  const result = await response.json();

  if (result.code === 200) {

    // 上传成功，使用返回的文件路径

    console.log("文件访问路径:", result.data);

  } else {

    // 处理错误

    console.error("上传失败:", result.message);

  }

};

```

### 4.2 文件类型限制

可以在控制器或服务层增加文件类型验证：

```java

// 检查文件类型是否允许

String contentType = file.getContentType();

if (!allowedTypes.contains(contentType)) {

    return Result.error("不支持的文件类型");

}

```

## 5 总结

文件上传功能像是一个完整的快递系统：

- 前端负责包装文件（前台）

- 控制器负责接收文件（接待员）

- 服务层负责处理和存储文件（仓库管理员）

- 实体类和数据库负责记录文件信息（登记簿）

- 配置类负责控制访问权限（门卫）

通过这样的设计，我们实现了一个安全、高效、易扩展的文件上传系统。无论是普通用户还是系统管理员，都能轻松地使用和维护这个系统。

文件就像是数字世界的物品，而我们的系统就像是一个高效的物流仓库，接收、存储、管理这些数字物品，让用户能够随时存入和取出自己的数字资产。